## API Report File for "@s809/noisecord"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ApplicationCommandSubCommandData } from 'discord.js';
import { Awaitable } from 'discord.js';
import { CacheType } from 'discord.js';
import { Channel } from 'discord.js';
import { ChannelType } from 'discord.js';
import { Client } from 'discord.js';
import { CommandInteraction } from 'discord.js';
import { ConditionalSimplifyDeep } from 'type-fest/source/conditional-simplify.js';
import { ContextMenuCommandInteraction } from 'discord.js';
import { Embed } from 'discord.js';
import format from 'string-format';
import { Guild } from 'discord.js';
import { GuildMember } from 'discord.js';
import { GuildResolvable } from 'discord.js';
import { GuildTextBasedChannel } from 'discord.js';
import { If } from 'discord.js';
import { Interaction } from 'discord.js';
import { InteractionCollector } from 'discord.js';
import { InteractionEditReplyOptions } from 'discord.js';
import { InteractionReplyOptions } from 'discord.js';
import { IsLiteral } from 'type-fest';
import { IterableElement } from 'type-fest';
import { LocaleString } from 'discord.js';
import { LocalizationMap } from 'discord.js';
import { MappedInteractionTypes } from 'discord.js';
import { Message } from 'discord.js';
import { MessageApplicationCommandData } from 'discord.js';
import { MessageCollectorOptionsParams } from 'discord.js';
import { MessageComponentType } from 'discord.js';
import { MessageCreateOptions } from 'discord.js';
import { MessageEditOptions } from 'discord.js';
import { MessageFlagsBitField } from 'discord.js';
import { MessageReplyOptions } from 'discord.js';
import { PermissionResolvable } from 'discord.js';
import { Role } from 'discord.js';
import { SimpleMerge } from 'type-fest/source/merge.js';
import { Snowflake } from 'discord.js';
import { TextBasedChannel } from 'discord.js';
import { UnionToIntersection } from 'type-fest';
import { User } from 'discord.js';
import { UserApplicationCommandData } from 'discord.js';

// @public (undocumented)
export class AllLocalesPathTranslator {
    // @internal
    constructor(path: string);
    // (undocumented)
    getTranslation(context: TranslationContextResolvable, ...args: FormatParameters): Promise<string>;
    // @internal (undocumented)
    translatorManager?: TranslatorManager;
}

// @public (undocumented)
export class ArgumentParseError extends Error {
    // @internal
    constructor(message: string);
}

// @public
export function checkConditions(context: CommandContextResolvable, conditions: CommandCondition[]): string | null;

// @public
export function checkConditions(context: CommandContextResolvable, command: Command): string | null;

// @public (undocumented)
export type Command = SimpleMerge<Required<CommandDefinition>, {
    path: string;
    key: string;
    translationPath: string;
    nameTranslations: LocalizationMap;
    descriptionTranslations: LocalizationMap;
    usageTranslations: LocalizationMap;
    ownerOnly: boolean;
    defaultMemberPermissions: PermissionResolvable;
    allowDMs: boolean;
    conditions: CommandCondition[];
    interactionCommand: {
        id: Snowflake | null;
    } | null;
    args: {
        min: number;
        max: number;
        stringTranslations: LocalizationMap;
        list: (IterableElement<NonNullable<ApplicationCommandSubCommandData["options"]>> & {
            key: string;
        })[];
        lastArgAsExtras: boolean;
    };
    handler: CommandHandler | null;
    subcommands: Map<string, Command>;
}>;

// @public (undocumented)
export interface CommandCondition {
    // (undocumented)
    check: (context: CommandContextResolvable) => boolean;
    // (undocumented)
    failureMessage: string;
    // (undocumented)
    hideCommand?: boolean | ((context: CommandContextResolvable) => boolean);
    // (undocumented)
    hideInDescription?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    requires?: CommandCondition | CommandCondition[];
    // (undocumented)
    satisfiedBy?: CommandCondition | CommandCondition[];
}

// @public (undocumented)
export type CommandContextResolvable = Message | CommandRequest;

// @public (undocumented)
export interface CommandDefinition {
    // (undocumented)
    allowDMs?: boolean;
    // (undocumented)
    alwaysReactOnSuccess?: boolean;
    // (undocumented)
    args?: (DistributiveOmit<IterableElement<NonNullable<ApplicationCommandSubCommandData["options"]>>, "name" | "nameLocalizations" | "description" | "descriptionLocalizations" | "choices"> & {
        key: string;
        choices?: {
            key: string;
            value: string | number;
        }[];
        isExtras?: boolean;
    })[];
    // (undocumented)
    conditions?: CommandCondition | CommandCondition[];
    // (undocumented)
    defaultMemberPermissions?: PermissionResolvable | null;
    // (undocumented)
    handler?: CommandHandler;
    // (undocumented)
    interactionCommand?: boolean;
    // (undocumented)
    key: string;
    // (undocumented)
    ownerOnly?: boolean;
}

// @public
export class CommandFramework {
    constructor(options: CommandFrameworkOptions);
    // (undocumented)
    get commandRegistry(): CommandRegistry;
    get commands(): ReadonlyMap<string, Readonly<Command>>;
    init(client: Client): Promise<this>;
    // (undocumented)
    readonly translationChecker: TranslationChecker;
    // (undocumented)
    get translatorManager(): TranslatorManager;
}

// @public
export interface CommandFrameworkOptions {
    // (undocumented)
    commandRegistryOptions: CommandRegistryOptions;
    // (undocumented)
    interactionCommands?: InteractionHandlerOptions;
    // (undocumented)
    messageCommands?: MessageHandlerOptions;
    // (undocumented)
    translationOptions: TranslatorManagerOptions;
}

// @public (undocumented)
export type CommandHandler = (req: CommandRequest, args: ParsedArguments) => Awaitable<string | void>;

// @public
export class CommandRegistry {
    // @internal
    constructor(options: CommandRegistryOptions, translatorManager: TranslatorManager);
    // (undocumented)
    readonly commands: Map<string, Command>;
    // (undocumented)
    readonly commandsById: Map<Snowflake, Map<string, Command> | ContextMenuCommand>;
    // (undocumented)
    readonly commandsByLocale: Map<LocaleString, DeeplyNestedMap<Command>>;
    // (undocumented)
    readonly contextMenuCommands: ContextMenuCommand[];
    // @internal (undocumented)
    createCommands(): Promise<this>;
    // @internal (undocumented)
    createContextMenuCommands(): Promise<ContextMenuCommand<ContextMenuCommandInteraction<CacheType>>[]>;
    getCommandUsageString(command: Command, prefix: string, translator: Translator): string;
    iterateCommands(): Iterable<Command>;
    iterateSubcommands(list: ReadonlyMap<string, Command>): Iterable<Command>;
    resolveCommandByLocalizedPath(path: string | string[], translator: Translator, allowFallback?: boolean): Command | null;
    resolveCommandByPath(path: string | string[], allowPartialResolve?: boolean): Command | null;
    // (undocumented)
    readonly translatorManager: TranslatorManager;
}

// @public
export interface CommandRegistryOptions {
    // (undocumented)
    commandModuleDirectory?: string;
    // (undocumented)
    contextMenuModuleDirectory?: string;
}

// @public
export abstract class CommandRequest<InGuild extends boolean = boolean> {
    // @internal
    constructor(command: Command, translator: Translator);
    // (undocumented)
    abstract get author(): User;
    // (undocumented)
    abstract get channel(): If<InGuild, GuildTextBasedChannel, TextBasedChannel> & {
        send: never;
    };
    // (undocumented)
    get channelId(): string;
    // (undocumented)
    readonly command: Command;
    completeSilently(): Promise<void>;
    // (undocumented)
    abstract get content(): string | null;
    abstract deferReply(ephemeral?: boolean): Promise<CommandResponse>;
    // (undocumented)
    abstract get guild(): If<InGuild, Guild>;
    // (undocumented)
    get guildId(): If<InGuild, Snowflake>;
    // (undocumented)
    abstract inGuild(): this is CommandRequest<true>;
    // (undocumented)
    abstract get member(): If<InGuild, GuildMember>;
    abstract reply(options: string | InteractionReplyOptions | MessageReplyOptions): Promise<CommandResponse>;
    replyOrSendSeparate(options: InteractionReplyOptions | MessageReplyOptions): Promise<CommandResponse>;
    get response(): CommandResponse | null;
    // (undocumented)
    _response: CommandResponse | null;
    abstract sendSeparate(options: string | MessageReplyOptions): Promise<CommandResponse>;
    // (undocumented)
    readonly translator: Translator;
}

// @public
export abstract class CommandResponse {
    // @internal
    constructor(message?: Message<boolean> | undefined);
    get content(): string | undefined;
    abstract createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes[T]>;
    abstract delete(): Promise<void>;
    abstract edit(options: string | MessageCreateOptions | MessageEditOptions | InteractionEditReplyOptions | InteractionReplyOptions): Promise<this>;
    get embeds(): Embed[] | undefined;
    get flags(): Readonly<MessageFlagsBitField> | undefined;
    // (undocumented)
    protected message?: Message<boolean> | undefined;
}

// @public (undocumented)
export class CommandResultError extends Error {
    // @internal
    constructor(message: string);
}

// @public (undocumented)
export interface ContextMenuCommand<T extends ContextMenuCommandInteraction = ContextMenuCommandInteraction> extends ContextMenuCommandDefinition<T> {
    // (undocumented)
    appCommandData: UserApplicationCommandData | MessageApplicationCommandData;
    // (undocumented)
    appCommandId: Snowflake | null;
}

// @public (undocumented)
export interface ContextMenuCommandDefinition<T extends ContextMenuCommandInteraction = ContextMenuCommandInteraction> {
    // (undocumented)
    handler: (interaction: T, translator: Translator) => void;
    // (undocumented)
    key: string;
    // (undocumented)
    type: T["commandType"];
}

// @public (undocumented)
export type DeeplyNestedMap<V> = Map<string, V | DeeplyNestedMap<V>>;

// @public (undocumented)
export class DefaultLocalePathTranslator {
    // @internal
    constructor(path: string);
    // (undocumented)
    getTranslation(...args: FormatParameters): string;
    // @internal (undocumented)
    translatorManager?: TranslatorManager;
}

// @public
export function defineCommand<T extends CommandDefinition | ContextMenuCommandDefinition = CommandDefinition>(definition: T): T;

// @public (undocumented)
export type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;

// @public (undocumented)
export class ErrorCollector {
    constructor(errorMessage?: string | undefined);
    // (undocumented)
    addError(message: string): void;
    // (undocumented)
    get groupChainLength(): number;
    // (undocumented)
    setHeader(level: number, header: string): void;
    // (undocumented)
    throwIfErrors(): void;
}

// @internal (undocumented)
export abstract class _EventHandler<Args extends any[], TConvertedOptions extends Required<_HandlerOptions>> {
    protected constructor(client: Client, commandRegistry: CommandRegistry, options: Omit<TConvertedOptions, keyof Required<_HandlerOptions>> & _TypedHandlerOptions<TConvertedOptions>, defaultStatusHandlers: Omit<Required<_TypedHandlerOptions<TConvertedOptions>>, "slowCommandDelayMs">);
    // (undocumented)
    protected readonly client: Client;
    // (undocumented)
    protected readonly commandRegistry: CommandRegistry;
    // (undocumented)
    readonly defaultStatusHandlers: Omit<Required<_TypedHandlerOptions<TConvertedOptions>>, "slowCommandDelayMs">;
    // (undocumented)
    protected abstract readonly eventName: string;
    // (undocumented)
    protected executeCommand(CommandRequest: _HandlerOptionsType<TConvertedOptions>, execute: () => Awaitable<string | void>, translator: Translator): Promise<void>;
    // (undocumented)
    protected abstract handle(...args: Args): Promise<void>;
    // (undocumented)
    init(): Promise<this>;
    // (undocumented)
    protected readonly options: TConvertedOptions;
    // (undocumented)
    protected splitByWhitespace(str: string): string[];
    // (undocumented)
    protected readonly translatorManager: TranslatorManager;
}

// @public
export const failureEmoji = "\u274C";

// @public (undocumented)
export type FormatParameters = Parameters<typeof format>[1][];

// @internal (undocumented)
export function _getValueOrThrowInitError<T>(value: T | undefined, instance: {
    init: Function;
}): T & ({} | null);

// @public (undocumented)
export interface _HandlerOptions<TCommandRequest = CommandRequest> {
    onFailure?: (req: TCommandRequest, error: Error) => Awaitable<void>;
    onSlowCommand?: (req: TCommandRequest) => Awaitable<void>;
    onSuccess?: (req: TCommandRequest) => Awaitable<void>;
    // (undocumented)
    slowCommandDelayMs?: number;
}

// @internal (undocumented)
export type _HandlerOptionsType<T> = T extends _HandlerOptions<infer T> ? T : never;

// @public (undocumented)
export class InteractionCommandResponse extends CommandResponse {
    // @internal
    constructor(interaction: CommandInteraction, message: Message);
    createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes<boolean>[T]>;
    delete(): Promise<void>;
    edit(options: string | MessageCreateOptions | MessageEditOptions | InteractionReplyOptions): Promise<this>;
    // (undocumented)
    readonly interaction: CommandInteraction;
}

// @internal (undocumented)
export class _InteractionHandler extends _EventHandler<[Interaction], Required<InteractionHandlerOptions>> {
    constructor(client: Client, commandRegistry: CommandRegistry, options: InteractionHandlerOptions);
    // (undocumented)
    protected readonly eventName = "interactionCreate";
    // (undocumented)
    handle(interaction: Interaction): Promise<void>;
    // (undocumented)
    init(): Promise<this>;
}

// @public
export interface InteractionHandlerOptions extends _HandlerOptions<CommandRequest | ContextMenuCommandInteraction> {
    // (undocumented)
    registerApplicationCommands?: boolean;
}

// @public (undocumented)
export const InVoiceChannel: CommandCondition;

// @public (undocumented)
export const InVoiceWithBot: CommandCondition;

// @public
export const loadingEmoji = "\uD83D\uDD04";

// @public
export class MessageCommandRequest<InGuild extends boolean = boolean> extends CommandRequest<InGuild> {
    // @internal
    constructor(command: Command, translator: Translator, message: Message);
    // (undocumented)
    get author(): User;
    // (undocumented)
    get channel(): CommandRequest<InGuild>["channel"];
    // (undocumented)
    get content(): string;
    deferReply(): Promise<MessageCommandResponse>;
    // (undocumented)
    get guild(): CommandRequest<InGuild>["guild"];
    // (undocumented)
    inGuild(): this is MessageCommandRequest<true>;
    // (undocumented)
    get member(): CommandRequest<InGuild>["member"];
    // (undocumented)
    readonly message: Message;
    reply(options: string | MessageReplyOptions): Promise<MessageCommandResponse>;
    sendSeparate(options: string | MessageReplyOptions): Promise<MessageCommandResponse>;
}

// @public (undocumented)
export class MessageCommandResponse extends CommandResponse {
    // @internal
    constructor(message: Message);
    // @internal
    constructor(deferChannel: TextBasedChannel);
    createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes<boolean>[T]>;
    delete(): Promise<void>;
    edit(options: string | MessageCreateOptions | MessageEditOptions | InteractionEditReplyOptions | InteractionReplyOptions): Promise<this>;
}

// @internal (undocumented)
export class _MessageHandler extends _EventHandler<[Message], _MessageHandlerConvertedOptions> {
    constructor(client: Client, commandRegistry: CommandRegistry, options: MessageHandlerOptions);
    // (undocumented)
    protected readonly eventName = "messageCreate";
    // (undocumented)
    handle(msg: Message): Promise<void>;
}

// @internal (undocumented)
export interface _MessageHandlerConvertedOptions extends Required<_HandlerOptions> {
    // (undocumented)
    getPrefix: (msg: Message) => Awaitable<string | null>;
    // (undocumented)
    shouldIgnorePermissions: (msg: Message) => Awaitable<boolean>;
}

// @public
export interface MessageHandlerOptions extends _HandlerOptions {
    ignorePermissionsFor?: Snowflake | Snowflake[] | ((msg: Message) => Awaitable<boolean>);
    prefix: string | Map<Snowflake | null, string> | ((msg: Message) => Awaitable<string | null>);
}

// @public
export function parseChannelMention(text: string): string | null;

// @public (undocumented)
export type ParsedArguments = Record<string, string | string[] | number | boolean | User | Channel | Role>;

// @public
export function parseMention(text: string, prefix: string): string | null;

// @public
export function parseRoleMention(text: string): string | null;

// @public
export function parseUserMention(text: string): string | null;

// @public (undocumented)
export type PathTranslators<Input extends Record<string, boolean>> = ConditionalSimplifyDeep<UnionToIntersectionRecursive<{
    [K in keyof Input as K extends `${infer Head}.${any}` ? Head : K]: K extends `${string}.${infer Rest}` ? PathTranslators<{
        [K2 in Rest]: Input[K];
    }> : K extends string ? IsLiteral<Input[K]> extends true ? Input[K] extends true ? AllLocalesPathTranslator : DefaultLocalePathTranslator : never : never;
}>, PathTranslatorTypes>;

// @public (undocumented)
export type PathTranslatorTypes = DefaultLocalePathTranslator | AllLocalesPathTranslator;

// @public
export const successEmoji = "\u2705";

// @public (undocumented)
export const textChannels: readonly [ChannelType.GuildAnnouncement, ChannelType.PublicThread, ChannelType.PrivateThread, ChannelType.AnnouncementThread, ChannelType.GuildText];

// @public (undocumented)
export class TranslationChecker extends ErrorCollector {
    // @internal
    constructor();
    checkTranslations<Paths extends Record<string, boolean>>(data: Paths, prefix?: string): PathTranslators<Paths>;
    // @internal (undocumented)
    runChecks(translatorManager: TranslatorManager): void;
}

// @public (undocumented)
export type TranslationContextResolvable = string | Message | CommandInteraction | GuildResolvable | User;

// @public
export class Translator {
    // @internal
    constructor(data: object, errorCollector: ErrorCollector);
    // @internal
    constructor(root: Translator, prefixOrFallback: string | Translator);
    readonly booleanValues: [string[], string[]];
    get fallback(): Translator | null;
    getTranslationFromRecord(obj: Partial<Record<LocaleString, any>>): any;
    readonly localeString: LocaleString;
    readonly root: Translator | null;
    // @internal (undocumented)
    setFallback(fallback: Translator): void;
    readonly setLocaleRegex: RegExp;
    translate(path: string, ...args: FormatParameters): string;
    tryTranslate(path: string, ...args: FormatParameters): string | null;
}

// @public (undocumented)
export class TranslatorManager {
    constructor(options: TranslatorManagerOptions);
    // (undocumented)
    get fallbackLocale(): "id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi";
    // (undocumented)
    get fallbackTranslator(): Translator;
    // (undocumented)
    getLocale(nameOrContext: TranslationContextResolvable): Promise<string | null>;
    // (undocumented)
    getLocalizations(translationPath: string): Partial<Record<"id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi", string>>;
    // (undocumented)
    getTranslator(nameOrContext: TranslationContextResolvable, prefix?: string): Promise<Translator>;
    // @internal (undocumented)
    init(): Promise<this>;
    // (undocumented)
    readonly rootTranslators: Translator[];
    // (undocumented)
    readonly setLocaleRegexes: Record<"id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi", RegExp>;
}

// @public (undocumented)
export interface TranslatorManagerOptions {
    // (undocumented)
    defaultLocale: LocaleString;
    // (undocumented)
    getGuildLocale: (guild: Guild) => Promise<LocaleString | null>;
    // (undocumented)
    getUserLocale: (user: User) => Promise<LocaleString | null>;
    // (undocumented)
    translationFileDirectory: string;
}

// @internal (undocumented)
export function _traverseTree<T>(path: string[], root: ReadonlyMap<string, T>, getDescendants: (value: T) => Map<string, T> | null | undefined, allowPartialResolve?: boolean): T | null;

// @internal (undocumented)
export type _TypedHandlerOptions<T> = _HandlerOptions<_HandlerOptionsType<T>>;

// @public (undocumented)
export type UnionToIntersectionRecursive<T> = {
    [K in keyof T]: T[K] extends {} ? UnionToIntersection<T[K]> : UnionToIntersectionRecursive<T[K]>;
};

// (No @packageDocumentation comment for this package)

```
