## API Report File for "@s809/noisecord"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ApplicationCommandOptionType } from 'discord.js';
import { ApplicationCommandSubCommandData } from 'discord.js';
import { ApplicationCommandType } from 'discord.js';
import { ArgumentParseError as ArgumentParseError_2 } from './errors/ArgumentParseError.js';
import { Awaitable } from 'discord.js';
import { CacheType } from 'discord.js';
import { ChannelType } from 'discord.js';
import { Client } from 'discord.js';
import { ClientEvents } from 'discord.js';
import { Command as Command_2 } from './index.js';
import { CommandInteraction } from 'discord.js';
import { CommandResponse as CommandResponse_2 } from './CommandResponse.js';
import { ConditionalSimplifyDeep } from 'type-fest/source/conditional-simplify.js';
import { ContextMenuCommandInteraction } from 'discord.js';
import { Embed } from 'discord.js';
import { Guild } from 'discord.js';
import { GuildMember } from 'discord.js';
import { GuildResolvable } from 'discord.js';
import { GuildTextBasedChannel } from 'discord.js';
import { If } from 'discord.js';
import { Interaction } from 'discord.js';
import { InteractionCollector } from 'discord.js';
import { InteractionEditReplyOptions } from 'discord.js';
import { InteractionReplyOptions } from 'discord.js';
import { IsLiteral } from 'type-fest';
import { IterableElement } from 'type-fest';
import { LocaleString } from 'discord.js';
import { LocalizationMap } from 'discord.js';
import { MappedInteractionTypes } from 'discord.js';
import { Merge } from 'type-fest';
import { Message } from 'discord.js';
import { MessageApplicationCommandData } from 'discord.js';
import { MessageCollectorOptionsParams } from 'discord.js';
import { MessageComponentType } from 'discord.js';
import { MessageContextMenuCommandInteraction } from 'discord.js';
import { MessageCreateOptions } from 'discord.js';
import { MessageEditOptions } from 'discord.js';
import { MessageFlagsBitField } from 'discord.js';
import { MessageReplyOptions } from 'discord.js';
import { PermissionResolvable } from 'discord.js';
import { Primitive } from 'type-fest';
import { Role } from 'discord.js';
import { Simplify } from 'type-fest';
import { Snowflake } from 'discord.js';
import { TextBasedChannel } from 'discord.js';
import { UnionToIntersection } from 'type-fest';
import { User } from 'discord.js';
import { UserApplicationCommandData } from 'discord.js';
import { UserContextMenuCommandInteraction } from 'discord.js';

// @public (undocumented)
export class AllLocalesPathTranslator {
    // @internal
    constructor(path: string);
    // (undocumented)
    getTranslation(context: TranslatorManager.ContextResolvable, args?: Translator.FormatParameters): Promise<string>;
    // (undocumented)
    getTranslation(context: CommandRequest | Translator, args?: Translator.FormatParameters): string;
    // (undocumented)
    readonly path: string;
    // @internal (undocumented)
    translatorManager?: TranslatorManager;
}

// @public (undocumented)
export type AllowDMsCacheType<AllowDMs extends boolean> = InGuildCacheType<AllowDMs extends true ? false : true>;

// @public (undocumented)
export type AllowDMsInGuild<AllowDMs> = AllowDMs extends true ? boolean : true;

// @public (undocumented)
export class ArgumentParseError<TReason extends keyof ArgumentParseError.CauseMap = any> extends Error {
    // @internal
    constructor(message: TReason, isSingle: TReason extends keyof ArgumentParseError.SingleCauseMap ? true : false, cause: ArgumentParseError.CauseMap[TReason]);
    // (undocumented)
    readonly cause: ArgumentParseError.CauseMap[TReason];
    // (undocumented)
    hasReason<T extends TReason>(reason: T): this is ArgumentParseError<T>;
    // (undocumented)
    isSingle(): this is ArgumentParseError<Extract<TReason, keyof ArgumentParseError.SingleCauseMap>>;
    // (undocumented)
    readonly message: TReason;
}

// @public (undocumented)
export namespace ArgumentParseError {
    // (undocumented)
    export type CauseMap = SingleCauseMap & Record<keyof SingleCauseMap, {
        argKey: string;
        argValue: string;
    }> & {
        too_few_arguments: {
            argCount: number;
            minArgs: number;
        };
        too_many_arguments: {
            argCount: number;
            maxArgs: number;
        };
    };
    // (undocumented)
    export interface SingleCauseMap {
        // (undocumented)
        channel_constraints_not_met: {};
        // (undocumented)
        invalid_channel: {};
        // (undocumented)
        invalid_numeric: {};
        // (undocumented)
        invalid_role: {};
        // (undocumented)
        invalid_user: {};
        // (undocumented)
        unsupported_argument_type: {
            type: string;
        };
        // (undocumented)
        value_not_allowed: {
            allowedValues: string;
            allowedValuesItems: string[];
        };
        // (undocumented)
        value_too_large: {
            maxValue: number;
        };
        // (undocumented)
        value_too_long: {
            maxLength: number;
        };
        // (undocumented)
        value_too_short: {
            minLength: number;
        };
        // (undocumented)
        value_too_small: {
            minValue: number;
        };
    }
}

// @public (undocumented)
export const BuiltInCommandConditions: {
    InVoiceChannel: CommandCondition;
    InVoiceWithBot: CommandCondition;
};

// @internal
export function _checkConditions(context: CommandRequest, source: Command | CommandCondition[]): string | null;

// @public (undocumented)
export interface Command {
    // (undocumented)
    allowDMs: boolean;
    // (undocumented)
    args: Command.ArgumentData;
    // (undocumented)
    conditions: CommandCondition[];
    // (undocumented)
    defaultMemberPermissions: PermissionResolvable;
    // (undocumented)
    descriptionTranslations: LocalizationMap;
    // (undocumented)
    handler: Command.Handler | null;
    // (undocumented)
    interactionCommand: Command.InteractionCommandData | null;
    // (undocumented)
    key: string;
    // (undocumented)
    nameTranslations: LocalizationMap;
    // (undocumented)
    ownerOnly: boolean;
    // (undocumented)
    path: string;
    // (undocumented)
    subcommands: Map<string, Command>;
    // (undocumented)
    translationPath: string;
    // (undocumented)
    usageTranslations: LocalizationMap;
}

// @public (undocumented)
export namespace Command {
    // (undocumented)
    export interface ArgumentData {
        // (undocumented)
        lastArgumentType: "extras" | "raw" | null;
        // (undocumented)
        list: Simplify<(IterableElement<NonNullable<ApplicationCommandSubCommandData["options"]>> & {
            key: string;
        })>[];
        // (undocumented)
        max: number;
        // (undocumented)
        min: number;
        // (undocumented)
        stringTranslations: LocalizationMap;
    }
    // (undocumented)
    export type Handler<OwnerOnly extends boolean = boolean, AllowDMs extends boolean = boolean, Args extends HandlerArguments = HandlerArguments> = (req: OwnerOnly extends true ? MessageCommandRequest<AllowDMsInGuild<AllowDMs>> : CommandRequest<AllowDMsInGuild<AllowDMs>>, args: Args) => Awaitable<string | void>;
    // (undocumented)
    export type HandlerArguments = Record<string, string | string[] | number | boolean | User | GuildTextBasedChannel | Role | undefined>;
    // (undocumented)
    export interface InteractionCommandData {
        // (undocumented)
        id: Snowflake | null;
    }
}

// @public
export interface CommandCondition {
    // (undocumented)
    check: (context: CommandRequest) => boolean;
    // (undocumented)
    key: string;
    // (undocumented)
    requires?: CommandCondition | CommandCondition[];
    // (undocumented)
    satisfiedBy?: CommandCondition | CommandCondition[];
}

// @public
export interface CommandDefinition<OwnerOnly extends boolean = boolean, AllowDMs extends boolean = boolean, Args extends readonly CommandDefinition.Argument[] = readonly CommandDefinition.Argument[]> {
    // (undocumented)
    allowDMs?: AllowDMs;
    // (undocumented)
    args?: Args;
    // (undocumented)
    conditions?: CommandCondition | CommandCondition[];
    // (undocumented)
    defaultMemberPermissions?: PermissionResolvable | null;
    // (undocumented)
    handler?: Command.Handler<OwnerOnly, AllowDMs, CommandDefinition.HandlerArguments<Args>>;
    // (undocumented)
    key: string;
    // (undocumented)
    ownerOnly?: OwnerOnly;
}

// @public (undocumented)
export namespace CommandDefinition {
    // (undocumented)
    export type Argument = Simplify<(DistributiveOmit<IterableElement<NonNullable<ApplicationCommandSubCommandData["options"]>>, "name" | "nameLocalizations" | "description" | "descriptionLocalizations" | "choices"> & {
        key: string;
        choices?: readonly {
            key: string;
            value: string | number;
        }[];
        extras?: boolean;
        raw?: boolean;
    })>;
    // (undocumented)
    export interface ArgumentToTypeMap<Extras extends boolean | undefined> {
        // (undocumented)
        [ApplicationCommandOptionType.Number]: number;
        // (undocumented)
        [ApplicationCommandOptionType.String]: Extras extends true ? string[] : string;
        // (undocumented)
        [ApplicationCommandOptionType.Integer]: number;
        // (undocumented)
        [ApplicationCommandOptionType.Boolean]: boolean;
        // (undocumented)
        [ApplicationCommandOptionType.User]: User;
        // (undocumented)
        [ApplicationCommandOptionType.Channel]: GuildTextBasedChannel;
        // (undocumented)
        [ApplicationCommandOptionType.Role]: Role;
    }
    // (undocumented)
    export type HandlerArguments<Args extends readonly Argument[]> = {
        [Item in Args[number] as Item["key"]]: Item["type"] extends keyof ArgumentToTypeMap<Item["extras"]> ? Item["choices"] extends readonly any[] ? Item["choices"][number]["value"] : ArgumentToTypeMap<Item["extras"]>[Item["type"]] | (Item["required"] extends false ? undefined : never) : never;
    };
}

// @public
export class CommandFramework {
    constructor(client: Client, options: CommandFrameworkOptions);
    // (undocumented)
    get commandRegistry(): CommandRegistry;
    get commands(): Map<string, Command_2>;
    static create(client: Client, options: CommandFrameworkOptions): Promise<CommandFramework>;
    init(): Promise<this>;
    // (undocumented)
    readonly translationChecker: TranslationChecker;
    // (undocumented)
    get translatorManager(): TranslatorManager;
}

// @public
export interface CommandFrameworkOptions {
    // (undocumented)
    commandRegistryOptions: CommandRegistryOptions;
    // (undocumented)
    commonHandlerOptions?: EventHandler.CommonHandlerOptions;
    // (undocumented)
    interactionCommands?: InteractionHandlerOptions;
    // (undocumented)
    messageCommands?: MessageHandlerOptions;
    // (undocumented)
    translationOptions?: TranslatorManagerOptions;
}

// @public
export class CommandRegistry {
    // @internal
    constructor(options: CommandRegistryOptions, translatorManager: TranslatorManager);
    // (undocumented)
    readonly commands: Map<string, Command>;
    // (undocumented)
    readonly commandsById: Map<Snowflake, Map<string, Command> | ContextMenuCommand>;
    // (undocumented)
    readonly commandsByLocale: Map<LocaleString, DeeplyNestedMap<Command>>;
    // (undocumented)
    readonly contextMenuCommands: ContextMenuCommand[];
    // @internal (undocumented)
    createCommands(): Promise<this>;
    // (undocumented)
    getCommandTranslationPath(path: string): string;
    // (undocumented)
    getCommandTranslationPath(key: string, contextMenu: true): string;
    getCommandUsageString(command: Command, prefix: string, translator: Translator): string;
    iterateCommands(): Iterable<Command>;
    iterateSubcommands(list: ReadonlyMap<string, Command>): Iterable<Command>;
    resolveCommandByLocalizedPath(path: string | string[], translator: Translator, allowFallback?: boolean): Command | null;
    resolveCommandByPath(path: string | string[], allowPartialResolve?: boolean): Command | null;
    // (undocumented)
    readonly translatorManager: TranslatorManager;
}

// @public
export interface CommandRegistryOptions {
    // (undocumented)
    commandModuleDirectory?: string;
    // (undocumented)
    contextMenuModuleDirectory?: string;
    // (undocumented)
    requireCommandTranslations?: boolean;
}

// @public
export abstract class CommandRequest<InGuild extends boolean = boolean, Response extends CommandResponse = CommandResponse> {
    // @internal
    constructor(translator: Translator, prefix: string,
    response: Response);
    // (undocumented)
    abstract get author(): User;
    // (undocumented)
    abstract get channel(): If<InGuild, GuildTextBasedChannel, TextBasedChannel>;
    // (undocumented)
    get channelId(): string;
    // (undocumented)
    abstract get guild(): If<InGuild, Guild>;
    // (undocumented)
    get guildId(): If<InGuild, Snowflake>;
    // (undocumented)
    abstract inGuild(): this is CommandRequest<true, Response>;
    // (undocumented)
    abstract get member(): If<InGuild, GuildMember>;
    // (undocumented)
    readonly prefix: string;
    abstract replyOrEdit(options: string | InteractionReplyOptions | MessageReplyOptions): Promise<Response>;
    readonly response: Response;
    // (undocumented)
    readonly translator: Translator;
}

// @public
export abstract class CommandResponse {
    get content(): string | null;
    abstract createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes[T]>;
    abstract delete(): Promise<void>;
    get embeds(): Embed[] | null;
    get flags(): Readonly<MessageFlagsBitField> | null;
    // (undocumented)
    protected _message?: Message;
    abstract replyOrEdit(options: string | MessageCreateOptions | MessageEditOptions | InteractionEditReplyOptions | InteractionReplyOptions): Promise<this>;
}

// @public (undocumented)
export interface ContextMenuCommand extends Required<ContextMenuCommandDefinition> {
    // (undocumented)
    appCommandData: UserApplicationCommandData | MessageApplicationCommandData;
    // (undocumented)
    appCommandId: Snowflake | null;
}

// @public (undocumented)
export interface ContextMenuCommandDefinition<InteractionType extends ContextMenuCommandDefinition.InteractionTypes = ContextMenuCommandDefinition.InteractionTypes, AllowDMs extends boolean = boolean> {
    // (undocumented)
    allowDMs?: AllowDMs;
    // (undocumented)
    handler: (interaction: InteractionCommandRequest<ContextMenuCommand, ContextMenuCommandDefinition.CommandTypeToInteraction<AllowDMsCacheType<AllowDMs>>[InteractionType]>) => void;
    // (undocumented)
    key: string;
    // (undocumented)
    type: InteractionType;
}

// @public (undocumented)
export namespace ContextMenuCommandDefinition {
    // (undocumented)
    export interface CommandTypeToInteraction<Cached extends CacheType> {
        // (undocumented)
        [ApplicationCommandType.User]: UserContextMenuCommandInteraction<Cached>;
        // (undocumented)
        [ApplicationCommandType.Message]: MessageContextMenuCommandInteraction<Cached>;
    }
    // (undocumented)
    export type InteractionTypes = ContextMenuCommandInteraction["commandType"];
}

// @public (undocumented)
export type DeeplyNestedMap<V> = Map<string, V | DeeplyNestedMap<V>>;

// @public (undocumented)
export class DefaultLocalePathTranslator {
    // @internal
    constructor(path: string);
    // (undocumented)
    getTranslation(args?: Translator.FormatParameters): string;
    // (undocumented)
    readonly path: string;
    // @internal (undocumented)
    translatorManager?: TranslatorManager;
}

// @public
export function defineCommand<const OwnerOnly extends boolean = false, const AllowDMs extends boolean = true, const Args extends readonly CommandDefinition.Argument[] = never[]>(definition: CommandDefinition<OwnerOnly, AllowDMs, Args>): CommandDefinition<OwnerOnly, AllowDMs, Args>;

// @public
export function defineContextMenuCommand<const InteractionType extends ContextMenuCommandDefinition.InteractionTypes, const AllowDMs extends boolean = true>(definition: ContextMenuCommandDefinition<InteractionType, AllowDMs>): ContextMenuCommandDefinition<InteractionType, AllowDMs>;

// @public (undocumented)
export type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;

// @public (undocumented)
export class ErrorCollector {
    constructor(errorMessage?: string | undefined);
    // (undocumented)
    addError(message: string): void;
    // (undocumented)
    get groupChainLength(): number;
    // (undocumented)
    setHeader(level: number, header: string): void;
    // (undocumented)
    throwIfErrors(): void;
}

// @public (undocumented)
export namespace EventHandler {
    export type CleanHandlerOptions<T> = EventHandlerOptions<HandlerOptionsCommandRequest<T>>;
    // (undocumented)
    export type CommonHandlerOptions = EventHandler["defaultCommonStatusHandlers"];
    // (undocumented)
    export type HandlerOptionsCommandRequest<T> = T extends EventHandlerOptions<infer T> ? T : never;
}

// @public (undocumented)
export abstract class EventHandler<Options extends EventHandlerOptions = EventHandlerOptions, EventName extends keyof ClientEvents = keyof ClientEvents> {
    protected constructor(client: Client, eventName: EventName, commandRegistry: CommandRegistry, options: Merge<Required<Options>, Partial<EventHandler.CleanHandlerOptions<Options>>>, defaultStatusHandlers: Merge<EventHandler.CleanHandlerOptions<Options>, Partial<EventHandler.CommonHandlerOptions>>);
    // (undocumented)
    protected readonly client: Client;
    // (undocumented)
    protected readonly commandRegistry: CommandRegistry;
    // (undocumented)
    readonly defaultCommonStatusHandlers: {
        slowCommandDelayMs: number;
        onInvalidArguments(this: EventHandler<EventHandlerOptions<CommandRequest<boolean, CommandResponse_2>>, keyof ClientEvents>, req: EventHandler.HandlerOptionsCommandRequest<Options>, command: Command, e: ArgumentParseError_2<any>, translator: Translator): Promise<void>;
        onConditionsUnsatisfied(this: EventHandler<EventHandlerOptions<CommandRequest<boolean, CommandResponse_2>>, keyof ClientEvents>, req: EventHandler.HandlerOptionsCommandRequest<Options>, key: string, translator: Translator): Promise<void>;
    };
    // (undocumented)
    readonly defaultStatusHandlers: EventHandler.CleanHandlerOptions<Options>;
    // (undocumented)
    protected readonly eventName: EventName;
    // (undocumented)
    protected executeCommand(commandRequest: EventHandler.HandlerOptionsCommandRequest<Options>, execute: () => Awaitable<string | void>, translator: Translator): Promise<void>;
    // (undocumented)
    protected abstract handle(...args: ClientEvents[EventName]): Promise<void>;
    // (undocumented)
    protected readonly options: Required<Options>;
    // (undocumented)
    protected replyConditionsUnsatisfied(commandRequest: CommandRequest, key: string, translator: Translator): Promise<void>;
    // (undocumented)
    protected replyInvalidArguments(commandRequest: CommandRequest, command: Command, e: Error, translator: Translator): Promise<void>;
    // (undocumented)
    protected splitByWhitespace(str: string): string[];
    // (undocumented)
    protected readonly translatorManager: TranslatorManager;
}

// @public (undocumented)
export interface EventHandlerOptions<TCommandRequest = CommandRequest> {
    onConditionsUnsatisfied: (this: EventHandler, req: TCommandRequest, key: string, translator: Translator) => Awaitable<void>;
    onFailure: (this: EventHandler, req: TCommandRequest, error: Error) => Awaitable<void>;
    onInvalidArguments: (this: EventHandler, req: TCommandRequest, command: Command, e: ArgumentParseError<any>, translator: Translator) => Awaitable<void>;
    onSlowCommand: (this: EventHandler, req: TCommandRequest) => Awaitable<void>;
    onSuccess: (this: EventHandler, req: TCommandRequest) => Awaitable<void>;
    // (undocumented)
    slowCommandDelayMs: number;
}

// @public
export const failureEmoji = "\u274C";

// @internal (undocumented)
export function _getValueOrThrowInitError<T>(value: T | undefined, instance: {
    init: Function;
}): T & ({} | null);

// @public (undocumented)
export type InGuildCacheType<InGuild extends boolean = true> = InGuild extends true ? Exclude<CacheType, undefined> : CacheType;

// @public
export class InteractionCommandRequest<CommandType extends Command | ContextMenuCommand, InteractionType extends CommandInteraction> extends CommandRequest<InteractionType extends CommandInteraction<InGuildCacheType> ? true : false, InteractionCommandResponse> {
    // @internal
    constructor(command: CommandType, translator: Translator, interaction: InteractionType);
    // (undocumented)
    get author(): User;
    // (undocumented)
    get channel(): CommandRequest<InteractionInGuild<InteractionType>>["channel"];
    // (undocumented)
    readonly command: CommandType;
    deferReply(ephemeral?: boolean): Promise<InteractionCommandResponse>;
    followUpForce(options: string | InteractionReplyOptions): Promise<Message<InteractionInGuild<InteractionType>>>;
    // (undocumented)
    get guild(): CommandRequest<InteractionInGuild<InteractionType>>["guild"];
    // (undocumented)
    inGuild(): this is InteractionCommandRequest<CommandType, CommandInteraction<InGuildCacheType>>;
    // (undocumented)
    readonly interaction: InteractionType;
    // (undocumented)
    get member(): CommandRequest<InteractionInGuild<InteractionType>>["member"];
    replyOrEdit(options: string | InteractionReplyOptions): Promise<InteractionCommandResponse>;
}

// @public (undocumented)
export class InteractionCommandResponse extends CommandResponse {
    // @internal
    constructor(interaction: CommandInteraction);
    createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes<boolean>[T]>;
    // (undocumented)
    defer(ephemeral?: boolean): Promise<this>;
    // (undocumented)
    get deferredOrReplied(): boolean;
    delete(): Promise<void>;
    followUpForce(options: string | InteractionReplyOptions): Promise<Message<boolean>>;
    // (undocumented)
    readonly interaction: CommandInteraction;
    // (undocumented)
    get repliedFully(): boolean;
    replyOrEdit(options: string | InteractionReplyOptions | InteractionEditReplyOptions): Promise<this>;
}

// @internal (undocumented)
export class _InteractionHandler extends EventHandler<Required<InteractionHandlerOptions>, "interactionCreate"> {
    constructor(client: Client, commandRegistry: CommandRegistry, options: InteractionHandlerOptions);
    // (undocumented)
    static create(client: Client, commandRegistry: CommandRegistry, options: InteractionHandlerOptions): Promise<_InteractionHandler>;
    // (undocumented)
    handle(interaction: Interaction): Promise<void>;
}

// @public
export interface InteractionHandlerOptions extends Partial<EventHandlerOptions<InteractionCommandRequest<any, any>>> {
    // (undocumented)
    registerApplicationCommands?: boolean;
}

// @public (undocumented)
export type InteractionInGuild<T extends CommandInteraction> = T extends CommandInteraction<InGuildCacheType> ? true : false;

// @public
export const loadingEmoji = "\uD83D\uDD04";

// @public
export class MessageCommandRequest<InGuild extends boolean = boolean> extends CommandRequest<InGuild, MessageCommandResponse> {
    // @internal
    constructor(command: Command, translator: Translator, message: Message, prefix: string);
    // (undocumented)
    get author(): User;
    // (undocumented)
    get channel(): CommandRequest<InGuild>["channel"];
    // (undocumented)
    readonly command: Command;
    // (undocumented)
    get content(): string;
    // (undocumented)
    get guild(): CommandRequest<InGuild>["guild"];
    // (undocumented)
    inGuild(): this is MessageCommandRequest<true>;
    // (undocumented)
    get member(): CommandRequest<InGuild>["member"];
    // (undocumented)
    readonly message: Message;
    replyOrEdit(options: string | MessageReplyOptions): Promise<MessageCommandResponse>;
}

// @public (undocumented)
export class MessageCommandResponse extends CommandResponse {
    // @internal
    constructor(channel: TextBasedChannel);
    createMessageComponentCollector<T extends MessageComponentType>(options?: MessageCollectorOptionsParams<T>): InteractionCollector<MappedInteractionTypes<boolean>[T]>;
    delete(): Promise<void>;
    replyOrEdit(options: string | MessageCreateOptions | MessageEditOptions | InteractionEditReplyOptions | InteractionReplyOptions): Promise<this>;
}

// @internal (undocumented)
export class _MessageHandler extends EventHandler<_MessageHandlerConvertedOptions, "messageCreate"> {
    constructor(client: Client, commandRegistry: CommandRegistry, options: MessageHandlerOptions);
    // (undocumented)
    handle(msg: Message): Promise<void>;
}

// @internal (undocumented)
export interface _MessageHandlerConvertedOptions extends EventHandlerOptions<MessageCommandRequest> {
    // (undocumented)
    getPrefix: (msg: Message) => Awaitable<string | null>;
    // (undocumented)
    shouldIgnoreAllPermissions: (msg: Message, command: Command) => Awaitable<boolean>;
    // (undocumented)
    shouldIgnoreOwnerOnly: (msg: Message, command: Command) => Awaitable<boolean>;
}

// @public
export interface MessageHandlerOptions extends Partial<EventHandlerOptions> {
    ignoreAllPermissionsFor?: Snowflake | Snowflake[] | ((msg: Message, command: Command) => Awaitable<boolean>);
    ignoreOwnerOnlyFor?: Snowflake | Snowflake[] | ((msg: Message, command: Command) => Awaitable<boolean>);
    prefix: string | Map<Snowflake | null, string> | ((msg: Message) => Awaitable<string | null>);
}

// @public
export function parseChannelMention(text: string): string | null;

// @public
export function parseMention(text: string, prefix: string): string | null;

// @public
export function parseRoleMention(text: string): string | null;

// @public
export function parseUserMention(text: string): string | null;

// @public
export const successEmoji = "\u2705";

// @public (undocumented)
export const textChannels: (ChannelType.GuildText | ChannelType.GuildAnnouncement | ChannelType.AnnouncementThread | ChannelType.PublicThread | ChannelType.PrivateThread)[];

// @public (undocumented)
export namespace TranslationChecker {
    // (undocumented)
    export type PathTranslators<Input extends Record<string, boolean>> = ConditionalSimplifyDeep<UnionToIntersectionRecursive<{
        [K in keyof Input as K extends `${infer Head}.${any}` ? Head : K]: K extends `${string}.${infer Rest}` ? PathTranslators<{
            [K2 in Rest]: Input[K];
        }> : K extends string ? IsLiteral<Input[K]> extends true ? Input[K] extends true ? AllLocalesPathTranslator : DefaultLocalePathTranslator : never : never;
    }>, PathTranslatorTypes>;
    // (undocumented)
    export type PathTranslatorTypes = DefaultLocalePathTranslator | AllLocalesPathTranslator;
}

// @public (undocumented)
export class TranslationChecker extends ErrorCollector {
    // @internal
    constructor();
    checkTranslations<Paths extends Record<string, boolean>>(data: Paths, prefix?: string): TranslationChecker.PathTranslators<Paths>;
    // @internal (undocumented)
    runChecks(translatorManager: TranslatorManager): void;
}

// @public (undocumented)
export namespace Translator {
    // (undocumented)
    export type FormatParameters = Record<string, Exclude<Primitive, symbol>>;
}

// @public
export class Translator {
    // @internal
    constructor(data: object, errorCollector: ErrorCollector);
    // @internal
    constructor(root: Translator, prefixOrFallback: string | Translator);
    readonly booleanValues: [string[], string[]];
    get fallback(): Translator | null;
    getTranslationFromRecord(obj: Partial<Record<LocaleString, any>>): any;
    readonly localeString: LocaleString;
    readonly root: Translator | null;
    // @internal (undocumented)
    setFallback(fallback: Translator): void;
    readonly setLocaleRegex: RegExp;
    translate(path: string, args?: Translator.FormatParameters): string;
    tryTranslate(path: string, args?: Translator.FormatParameters): string | null;
}

// @public (undocumented)
export namespace TranslatorManager {
    // (undocumented)
    export type ContextResolvable = string | Message | CommandInteraction | GuildResolvable | User;
}

// @public (undocumented)
export class TranslatorManager {
    constructor(options?: TranslatorManagerOptions);
    // (undocumented)
    static readonly defaultDiscordLocale: LocaleString;
    // (undocumented)
    get fallbackLocale(): "id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi";
    // (undocumented)
    get fallbackTranslator(): Translator;
    // (undocumented)
    getLocale(nameOrContext: TranslatorManager.ContextResolvable): Promise<string | null>;
    // (undocumented)
    getLocalizations(translationPath: string): Partial<Record<"id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi", string>>;
    // (undocumented)
    getTranslator(nameOrContext: TranslatorManager.ContextResolvable, prefix?: string): Promise<Translator>;
    // @internal (undocumented)
    init(): Promise<this>;
    // (undocumented)
    readonly rootTranslators: Translator[];
    // (undocumented)
    readonly setLocaleRegexes: Record<"id" | "en-US" | "en-GB" | "bg" | "zh-CN" | "zh-TW" | "hr" | "cs" | "da" | "nl" | "fi" | "fr" | "de" | "el" | "hi" | "hu" | "it" | "ja" | "ko" | "lt" | "no" | "pl" | "pt-BR" | "ro" | "ru" | "es-ES" | "sv-SE" | "th" | "tr" | "uk" | "vi", RegExp>;
}

// @public (undocumented)
export interface TranslatorManagerOptions {
    // (undocumented)
    defaultLocale?: LocaleString;
    // (undocumented)
    getGuildLocale?: (guild: Guild) => Promise<LocaleString | null>;
    // (undocumented)
    getUserLocale?: (user: User) => Promise<LocaleString | null>;
    // (undocumented)
    translationFileDirectory?: string;
    // (undocumented)
    useBuiltInFallback?: boolean;
}

// @internal (undocumented)
export function _traverseTree<T>(path: string[], root: ReadonlyMap<string, T>, getDescendants: (value: T) => Map<string, T> | null | undefined, allowPartialResolve?: boolean): T | null;

// @public (undocumented)
export type UnionToIntersectionRecursive<T> = {
    [K in keyof T]: T[K] extends {} ? UnionToIntersection<T[K]> : UnionToIntersectionRecursive<T[K]>;
};

// (No @packageDocumentation comment for this package)

```
